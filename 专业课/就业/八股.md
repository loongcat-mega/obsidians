# c++
## 内存分配情况

- 栈：由编译器管理分配和回收，存放局部变量和函数参数
- 堆：程序员管理，手动申请和回收
- 全局/静态存储区：存放初始化和未初始化的全局变量和静态变量
- 常量存储区：存储常量，一般不允许修改
- 代码区：存放程序的二进制代码


## static

static 修饰的变量 ：改变生存周期 不改变作用域 ，存放在静态数据区，内存只被分配一次，值维持上次的值
类中static修饰的变量为整个类拥有，所有类对象只有一份拷贝
类中static修饰的成员函数为整个类拥有，只能访问类内的static成员变量



## const



## c vs c++

c++允许自定义命名空间
动态管理内存方式不同 new delete
增加了引用概念
支持重载和虚函数
模版
STL标准库

## 常量

- 局部常量 ： 存放在栈区
- 全局常量：编译期不分配内存，放在符号表中
- 字面值常量：常量区


## 重载和重写

重载：重名函数的不同调用和实现形式
重写：重新定义父类中的虚函数

## 指针和引用

都是内存地址的概念
指针是实体 ，内容是所指向的内存的地址，内容可变
引用是别名，内容是别名的值，后续不能修改

指针传参为值传递
引用传参为地址传递


## 堆与栈

栈：由编译器管理，自动分配空间，存放局部变量和函数参数等，一般为连续空间，向低地址生长

堆：由程序员管理，手动申请和释放内存，一般为不连续空间，向高地址扩展

## define 与 const

define：预处理阶段进行处理，没有类型，仅仅是对字符串得展开，运行时系统不为宏定义分配内存，占用代码段空间

const：编译期间处理，有类型，为const常量分配内存，占据数据段空间



## 面向对象三大特性

封装：把客观事物封装成抽象的类，并且类内有自己的数据结构和方法，即一个类就是封装了数据以及操作这些数据的代码的逻辑实体，并且类内有不同级别的访问权限，保护数据

继承：某个类对象获得另一个类对象的属性的方法

多态：向不同对象发送相同消息，不同对象产生不同行为


## 从代码到程序

- 预处理：头文件/宏展开
- 编译：将.i文件翻译成.s文件
- 汇编：将.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序，即.o文件，是一个二进制文件
- 链接：链接标准c库的目标文件


## 动态链接和静态链接

都是共享代码的方式

- 静态链接：把lib文件中用到的函数代码直接链接进目标程序，程序运行时不在需要其他库文件
- 动态链接：把调用的函数所在的文件模块dll等信息链接进目标程序，程序运行的时候再从DLL中寻找相应代码，因此需要dll支持

静态链接库中不能包含其他的静态/动态链接库




# 计网

## 为什么tcp需要三次握手和四次挥手

三次握手：
保证通信双方接受正常 发送正常
C--SYN=1-->S
S--SYN=1,ACK=1-->C
C--ACK=1-->S

四次挥手
保证收发双发完成数据传输
C--FIN=1-->S
S--ACK=1-->C
a few mintues later
S--FIN=1-->C
C--ACK=1-->S


# 操作系统

## fork，wait，exec

fork拷贝了父进程的副本，（重新申请PCB，并用父进程初始化），调用一次，返回两次，有三种返回值，与父进程采取写时拷贝机制，该值就分家

```perl
一个父进程希望复制自己，使父、子进程同时执行不同的代码段。这在网络服务进程种是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求到达
```

父进程调用wait会进入阻塞态，直到子进程状态发生改变

```perl
我们用fork函数创建新进程后，经常会在新进程中调用exec函数去执行另外一个程序。 当进程调用exec函数时，该进程被完全替换为新程序
```
